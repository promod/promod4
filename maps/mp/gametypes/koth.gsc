/*
  Copyright (c) 2009-2017 Andreas GÃ¶ransson <andreas.goransson@gmail.com>
  Copyright (c) 2009-2017 Indrek Ardel <indrek@ardel.eu>

  This file is part of Call of Duty 4 Promod.

  Call of Duty 4 Promod is licensed under Promod Modder Ethical Public License.
  Terms of license can be found in LICENSE.md document bundled with the project.
*/

#include maps\mp\_utility;
#include maps\mp\gametypes\_hud_util;

main()
{
    if ( getdvar("mapname") == "mp_background" )
        return;

    maps\mp\gametypes\_globallogic::init();
    maps\mp\gametypes\_callbacksetup::SetupCallbacks();
    maps\mp\gametypes\_globallogic::SetupCallbacks();

    level.teamBased = true;
    level.doPrematch = true;
    level.overrideTeamScore = true;
    level.onStartGameType = ::onStartGameType;
    level.onSpawnPlayer = ::onSpawnPlayer;
    level.onPlayerKilled = ::onPlayerKilled;
    level.onRoundSwitch = ::onRoundSwitch;

    precacheShader( "compass_waypoint_captureneutral" );
    precacheShader( "compass_waypoint_capture" );
    precacheShader( "compass_waypoint_defend" );

    precacheShader( "waypoint_targetneutral" );
    precacheShader( "waypoint_captureneutral" );
    precacheShader( "waypoint_capture" );
    precacheShader( "waypoint_defend" );

    precacheString( &"MP_WAITING_FOR_HQ" );

    level.hqAutoDestroyTime = getdvarint("koth_autodestroytime");
    level.hqSpawnTime = getdvarint("koth_spawntime");
    level.kothMode = getdvarint("koth_kothmode");
    level.captureTime = getdvarint("koth_captureTime");
    level.destroyTime = getdvarint("koth_destroyTime");
    level.delayPlayer = getdvarint("koth_delayPlayer");
    level.spawnDelay = getdvarint("koth_spawnDelay");

    level.iconoffset = (0,0,32);

    level.onRespawnDelay = ::getRespawnDelay;
}

updateObjectiveHintMessages( alliesObjective, axisObjective )
{
    game["strings"]["objective_hint_allies"] = alliesObjective;
    game["strings"]["objective_hint_axis"] = axisObjective;

    for ( i = 0; i < level.players.size; i++ )
    {
        player = level.players[i];
        if ( isDefined( player.pers["team"] ) && player.pers["team"] != "spectator" )
        {
            hintText = maps\mp\gametypes\_globallogic::getObjectiveHintText( player.pers["team"] );
            player thread maps\mp\gametypes\_hud_message::hintMessage( hintText );
        }
    }
}

getRespawnDelay()
{
    self.lowerMessageOverride = undefined;

    if ( !isDefined( level.radioObject ) )
        return undefined;

    hqOwningTeam = level.radioObject maps\mp\gametypes\_gameobjects::getOwnerTeam();
    if ( self.pers["team"] == hqOwningTeam )
    {
        if ( !isDefined( level.hqDestroyTime ) )
            return undefined;

        timeRemaining = (level.hqDestroyTime - gettime()) / 1000;

        if (!level.spawnDelay )
            return undefined;

        if ( level.spawnDelay >= level.hqAutoDestroyTime )
            self.lowerMessageOverride = &"MP_WAITING_FOR_HQ";

        if ( level.delayPlayer )
            return min( level.spawnDelay, timeRemaining );
        else
            return (int(timeRemaining) % level.spawnDelay);
    }
}

onStartGameType()
{
    maps\mp\gametypes\_globallogic::setObjectiveText( "allies", &"OBJECTIVES_KOTH" );
    maps\mp\gametypes\_globallogic::setObjectiveText( "axis", &"OBJECTIVES_KOTH" );
    maps\mp\gametypes\_globallogic::setObjectiveScoreText( "allies", &"OBJECTIVES_KOTH_SCORE" );
    maps\mp\gametypes\_globallogic::setObjectiveScoreText( "axis", &"OBJECTIVES_KOTH_SCORE" );

    level.objectiveHintPrepareHQ = &"MP_CONTROL_HQ";
    level.objectiveHintCaptureHQ = &"MP_CAPTURE_HQ";
    level.objectiveHintDestroyHQ = &"MP_DESTROY_HQ";
    level.objectiveHintDefendHQ = &"MP_DEFEND_HQ";

    precacheString( level.objectiveHintPrepareHQ );
    precacheString( level.objectiveHintCaptureHQ );
    precacheString( level.objectiveHintDestroyHQ );
    precacheString( level.objectiveHintDefendHQ );

    if ( level.kothmode )
        level.objectiveHintDestroyHQ = level.objectiveHintCaptureHQ;

    if ( level.hqSpawnTime )
        updateObjectiveHintMessages( level.objectiveHintPrepareHQ, level.objectiveHintPrepareHQ );
    else
        updateObjectiveHintMessages( level.objectiveHintCaptureHQ, level.objectiveHintCaptureHQ );

    setClientNameMode("auto_change");

    level.spawnMins = ( 0, 0, 0 );
    level.spawnMaxs = ( 0, 0, 0 );
    maps\mp\gametypes\_spawnlogic::addSpawnPoints( "allies", "mp_tdm_spawn" );
    maps\mp\gametypes\_spawnlogic::addSpawnPoints( "axis", "mp_tdm_spawn" );

    level.mapCenter = maps\mp\gametypes\_spawnlogic::findBoxCenter( level.spawnMins, level.spawnMaxs );
    setMapCenter( level.mapCenter );

    level.spawn_all = getentarray( "mp_tdm_spawn", "classname" );
    if ( !level.spawn_all.size )
    {
        if ( isDefined( level.restarting ) )
        {
            setdvar("g_gametype", "dm");
            setDvar( "o_gametype", "dm" );
        }
        else
            maps\mp\gametypes\_callbacksetup::AbortLevel();
        return;
    }

    allowed[0] = "hq";
    maps\mp\gametypes\_gameobjects::main(allowed);

    thread SetupRadios();

    thread HQMainLoop();
}

onRoundSwitch()
{
    level.halftimeType = "halftime";
}

HQMainLoop()
{
    level endon("game_ended");

    level.hqRevealTime = -100000;

    hqSpawningInStr = &"MP_HQ_AVAILABLE_IN";
    if ( level.kothmode )
    {
        hqDestroyedInFriendlyStr = &"MP_HQ_DESPAWN_IN";
        hqDestroyedInEnemyStr = &"MP_HQ_DESPAWN_IN";
    }
    else
    {
        hqDestroyedInFriendlyStr = &"MP_HQ_REINFORCEMENTS_IN";
        hqDestroyedInEnemyStr = &"MP_HQ_DESPAWN_IN";
    }

    precacheString( hqSpawningInStr );
    precacheString( hqDestroyedInFriendlyStr );
    precacheString( hqDestroyedInEnemyStr );
    precacheString( &"MP_CAPTURING_HQ" );
    precacheString( &"MP_DESTROYING_HQ" );

    if ( isDefined( game["promod_do_readyup"] ) && game["promod_do_readyup"] || game["PROMOD_MATCH_MODE"] == "strat")
        return;

    while ( level.inPrematchPeriod )
        wait 0.05;

    wait 5;

    timerDisplay = [];
    timerDisplay["allies"] = createServerTimer( "objective", 1.4, "allies" );
    timerDisplay["allies"] setPoint( "TOPRIGHT", "TOPRIGHT", 0, 0 );
    timerDisplay["allies"].label = hqSpawningInStr;
    timerDisplay["allies"].alpha = 0;
    timerDisplay["allies"].archived = false;
    timerDisplay["allies"].hideWhenInMenu = true;

    timerDisplay["axis"] = createServerTimer( "objective", 1.4, "axis" );
    timerDisplay["axis"] setPoint( "TOPRIGHT", "TOPRIGHT", 0, 0 );
    timerDisplay["axis"].label = hqSpawningInStr;
    timerDisplay["axis"].alpha = 0;
    timerDisplay["axis"].archived = false;
    timerDisplay["axis"].hideWhenInMenu = true;

    thread hideTimerDisplayOnGameEnd( timerDisplay["allies"] );
    thread hideTimerDisplayOnGameEnd( timerDisplay["axis"] );

    locationObjID = maps\mp\gametypes\_gameobjects::getNextObjID();

    objective_add( locationObjID, "invisible", (0,0,0) );

    for(;;)
    {
        radio = PickRadioToSpawn();

        iPrintLn( &"MP_HQ_REVEALED" );
        playSoundOnPlayers( "mp_suitcase_pickup" );

        radioObject = radio.gameobject;
        level.radioObject = radioObject;

        radioObject maps\mp\gametypes\_gameobjects::setModelVisibility( true );

        level.hqRevealTime = gettime();

        if ( level.hqSpawnTime )
        {
            nextObjPoint = maps\mp\gametypes\_objpoints::createTeamObjpoint( "objpoint_next_hq", radio.origin + level.iconoffset, "all", "waypoint_targetneutral" );
            nextObjPoint setWayPoint( true, "waypoint_targetneutral" );
            objective_position( locationObjID, radio.trigorigin );
            objective_icon( locationObjID, "compass_waypoint_captureneutral" );
            objective_state( locationObjID, "active" );

            updateObjectiveHintMessages( level.objectiveHintPrepareHQ, level.objectiveHintPrepareHQ );

            timerDisplay["allies"].label = hqSpawningInStr;
            timerDisplay["allies"] setTimer( level.hqSpawnTime );
            timerDisplay["allies"].alpha = 1;
            timerDisplay["axis"].label = hqSpawningInStr;
            timerDisplay["axis"] setTimer( level.hqSpawnTime );
            timerDisplay["axis"].alpha = 1;

            wait level.hqSpawnTime;

            maps\mp\gametypes\_objpoints::deleteObjPoint( nextObjPoint );
            objective_state( locationObjID, "invisible" );
        }

        timerDisplay["allies"].alpha = 0;
        timerDisplay["axis"].alpha = 0;

        waittillframeend;

        updateObjectiveHintMessages( level.objectiveHintCaptureHQ, level.objectiveHintCaptureHQ );
        playSoundOnPlayers( "mp_killstreak_radar" );

        radioObject maps\mp\gametypes\_gameobjects::enableObject();

        radioObject maps\mp\gametypes\_gameobjects::allowUse( "any" );
        radioObject maps\mp\gametypes\_gameobjects::setUseTime( level.captureTime );
        radioObject maps\mp\gametypes\_gameobjects::setUseText( &"MP_CAPTURING_HQ" );

        radioObject maps\mp\gametypes\_gameobjects::set2DIcon( "enemy", "compass_waypoint_captureneutral" );
        radioObject maps\mp\gametypes\_gameobjects::set3DIcon( "enemy", "waypoint_captureneutral" );
        radioObject maps\mp\gametypes\_gameobjects::setVisibleTeam( "any" );
        radioObject maps\mp\gametypes\_gameobjects::setModelVisibility( true );

        radioObject.onUse = ::onRadioCapture;
        radioObject.onBeginUse = ::onBeginUse;
        radioObject.onEndUse = ::onEndUse;

        level waittill( "hq_captured" );

        ownerTeam = radioObject maps\mp\gametypes\_gameobjects::getOwnerTeam();
        otherTeam = getOtherTeam( ownerTeam );

        if ( level.hqAutoDestroyTime )
        {
            thread DestroyHQAfterTime( level.hqAutoDestroyTime );
            timerDisplay[ownerTeam] setTimer( level.hqAutoDestroyTime );
            timerDisplay[otherTeam] setTimer( level.hqAutoDestroyTime );
        }
        else
            level.hqDestroyedByTimer = false;

        for(;;)
        {
            ownerTeam = radioObject maps\mp\gametypes\_gameobjects::getOwnerTeam();
            otherTeam = getOtherTeam( ownerTeam );

            if ( ownerTeam == "allies" )
                updateObjectiveHintMessages( level.objectiveHintDefendHQ, level.objectiveHintDestroyHQ );
            else
                updateObjectiveHintMessages( level.objectiveHintDestroyHQ, level.objectiveHintDefendHQ );

            radioObject maps\mp\gametypes\_gameobjects::allowUse( "enemy" );
            radioObject maps\mp\gametypes\_gameobjects::set2DIcon( "friendly", "compass_waypoint_defend" );
            radioObject maps\mp\gametypes\_gameobjects::set3DIcon( "friendly", "waypoint_defend" );
            radioObject maps\mp\gametypes\_gameobjects::set2DIcon( "enemy", "compass_waypoint_capture" );
            radioObject maps\mp\gametypes\_gameobjects::set3DIcon( "enemy", "waypoint_capture" );

            if ( !level.kothMode )
                radioObject maps\mp\gametypes\_gameobjects::setUseText( &"MP_DESTROYING_HQ" );

            radioObject.onUse = ::onRadioDestroy;

            if ( level.hqAutoDestroyTime )
            {
                timerDisplay[ownerTeam].label = hqDestroyedInFriendlyStr;
                timerDisplay[ownerTeam].alpha = 1;
                timerDisplay[otherTeam].label = hqDestroyedInEnemyStr;
                timerDisplay[otherTeam].alpha = 1;
            }

            level waittill( "hq_destroyed" );

            if ( !level.kothmode || level.hqDestroyedByTimer )
                break;

            thread forceSpawnTeam( ownerTeam );

            radioObject maps\mp\gametypes\_gameobjects::setOwnerTeam( getOtherTeam( ownerTeam ) );
        }

        level notify("hq_reset");

        radioObject maps\mp\gametypes\_gameobjects::disableObject();
        radioObject maps\mp\gametypes\_gameobjects::allowUse( "none" );
        radioObject maps\mp\gametypes\_gameobjects::setOwnerTeam( "neutral" );
        radioObject maps\mp\gametypes\_gameobjects::setModelVisibility( false );

        timerDisplay["allies"].alpha = 0;
        timerDisplay["axis"].alpha = 0;

        level.radioObject = undefined;

        wait 0.05;

        thread forceSpawnTeam( ownerTeam );

        wait 3;
    }
}

hideTimerDisplayOnGameEnd( timerDisplay )
{
    level waittill("game_ended");
    timerDisplay.alpha = 0;
}

forceSpawnTeam( team )
{
    for ( i = 0; i < level.players.size; i++ )
    {
        player = level.players[i];
        if ( !isdefined( player ) )
            continue;

        if ( player.pers["team"] == team )
        {
            player.lowerMessageOverride = undefined;
            player notify( "force_spawn" );
            wait 0.1;
        }
    }
}

onBeginUse( player )
{
    ownerTeam = self maps\mp\gametypes\_gameobjects::getOwnerTeam();

    if ( ownerTeam == "neutral" )
        self.objPoints[player.pers["team"]] thread maps\mp\gametypes\_objpoints::startFlashing();
    else
    {
        self.objPoints["allies"] thread maps\mp\gametypes\_objpoints::startFlashing();
        self.objPoints["axis"] thread maps\mp\gametypes\_objpoints::startFlashing();
    }
}

onEndUse( team, player, success )
{
    self.objPoints["allies"] thread maps\mp\gametypes\_objpoints::stopFlashing();
    self.objPoints["axis"] thread maps\mp\gametypes\_objpoints::stopFlashing();
}

onRadioCapture( player )
{
    team = player.pers["team"];

    player thread [[level.onXPEvent]]( "capture" );
    maps\mp\gametypes\_globallogic::givePlayerScore( "capture", player );

    oldTeam = maps\mp\gametypes\_gameobjects::getOwnerTeam();
    self maps\mp\gametypes\_gameobjects::setOwnerTeam( team );
    if ( !level.kothMode )
        self maps\mp\gametypes\_gameobjects::setUseTime( level.destroyTime );

    otherTeam = "axis";
    if ( team == "axis" )
        otherTeam = "allies";

    thread printOnTeamArg( &"MP_HQ_CAPTURED_BY", team, player );
    thread printOnTeam( &"MP_HQ_CAPTURED_BY_ENEMY", otherTeam );
    thread playSoundOnPlayers( "mp_war_objective_taken", team );
    thread playSoundOnPlayers( "mp_war_objective_lost", otherTeam );

    level thread awardHQPoints( team );

    level notify( "hq_captured" );

    if ( isDefined( level.scorebot ) && level.scorebot )
        game["promod_scorebot_ticker_buffer"] += "hq_captured" + player.name;

    logPrint("P_HQC;" + player getGuid() + ";" + player getEntityNumber() + ";" + player.name + "\n");
}

onRadioDestroy( player )
{
    team = player.pers["team"];
    otherTeam = "axis";
    if ( team == "axis" )
        otherTeam = "allies";

    player thread [[level.onXPEvent]]( "capture" );
    maps\mp\gametypes\_globallogic::givePlayerScore( "capture", player );

    if ( level.kothmode )
    {
        thread printOnTeamArg( &"MP_HQ_CAPTURED_BY", team, player );
        thread printOnTeam( &"MP_HQ_CAPTURED_BY_ENEMY", otherTeam );
    }
    else
    {
        thread printOnTeamArg( &"MP_HQ_DESTROYED_BY", team, player );
        thread printOnTeam( &"MP_HQ_DESTROYED_BY_ENEMY", otherTeam );
    }
    thread playSoundOnPlayers( "mp_war_objective_taken", team );
    thread playSoundOnPlayers( "mp_war_objective_lost", otherTeam );

    level notify( "hq_destroyed" );

    if ( level.kothmode )
        level thread awardHQPoints( team );

    if ( isDefined( level.scorebot ) && level.scorebot )
        game["promod_scorebot_ticker_buffer"] += "hq_destroyed" + player.name;

    logPrint("P_HQD;" + player getGuid() + ";" + player getEntityNumber() + ";" + player.name + "\n");
}

DestroyHQAfterTime( time )
{
    level endon( "game_ended" );
    level endon( "hq_reset" );

    level.hqDestroyTime = gettime() + time * 1000;
    level.hqDestroyedByTimer = false;

    wait time;

    level.hqDestroyedByTimer = true;
    level notify( "hq_destroyed" );
}

awardHQPoints( team )
{
    level endon( "game_ended" );
    level endon( "hq_destroyed" );

    level notify("awardHQPointsRunning");
    level endon("awardHQPointsRunning");

    seconds = 5;

    while ( !level.gameEnded )
    {
        [[level._setTeamScore]]( team, [[level._getTeamScore]]( team ) + seconds );
        for ( i = 0; i < level.players.size; i++ )
        {
            player = level.players[i];

            if ( player.pers["team"] == team )
            {
                player thread [[level.onXPEvent]]( "defend" );
                maps\mp\gametypes\_globallogic::givePlayerScore( "defend", player );
            }
        }

        wait seconds;
    }
}

onSpawnPlayer()
{
    spawnpoint = undefined;

    if ( isdefined( level.radioObject ) )
    {
        hqOwningTeam = level.radioObject maps\mp\gametypes\_gameobjects::getOwnerTeam();
        if ( self.pers["team"] == hqOwningTeam )
            spawnpoint = maps\mp\gametypes\_spawnlogic::getSpawnpoint_NearTeam( level.spawn_all, level.radioObject.nearSpawns );
        else if ( level.spawnDelay >= level.hqAutoDestroyTime && gettime() > level.hqRevealTime + 10000 )
            spawnpoint = maps\mp\gametypes\_spawnlogic::getSpawnpoint_NearTeam( level.spawn_all );
        else
            spawnpoint = maps\mp\gametypes\_spawnlogic::getSpawnpoint_NearTeam( level.spawn_all, level.radioObject.outerSpawns );
    }

    if ( !isDefined( spawnpoint ) )
        spawnpoint = maps\mp\gametypes\_spawnlogic::getSpawnpoint_NearTeam( level.spawn_all );

    self.lowerMessageOverride = undefined;

    self spawn( spawnpoint.origin, spawnpoint.angles );
}

SetupRadios()
{
    radios = getentarray( "hq_hardpoint", "targetname" );

    trigs = getentarray("radiotrigger", "targetname");
    for ( i = 0; i < radios.size; i++ )
    {
        radio = radios[i];
        radio.trig = undefined;
        for ( j = 0; j < trigs.size; j++ )
        {
            if ( radio istouching( trigs[j] ) )
            {
                radio.trig = trigs[j];
                break;
            }
        }

        radio.trigorigin = radio.trig.origin;

        visuals = [];
        visuals[0] = radio;

        otherVisuals = getEntArray( radio.target, "targetname" );
        for ( j = 0; j < otherVisuals.size; j++ )
            visuals[visuals.size] = otherVisuals[j];

        radio.gameObject = maps\mp\gametypes\_gameobjects::createUseObject( "neutral", radio.trig, visuals, (radio.origin - radio.trigorigin) + level.iconoffset );
        radio.gameObject maps\mp\gametypes\_gameobjects::disableObject();
        radio.gameObject maps\mp\gametypes\_gameobjects::setModelVisibility( false );
        radio.trig.useObj = radio.gameObject;

        radio setUpNearbySpawns();
    }

    level.radios = radios;

    level.prevradio = undefined;
    level.prevradio2 = undefined;

    return true;
}

setUpNearbySpawns()
{
    spawns = level.spawn_all;

    for ( i = 0; i < spawns.size; i++ )
        spawns[i].distsq = distanceSquared( spawns[i].origin, self.origin );

    for ( i = 1; i < spawns.size; i++ )
    {
        thespawn = spawns[i];
        for ( j = i - 1; j >= 0 && thespawn.distsq < spawns[j].distsq; j-- )
            spawns[j + 1] = spawns[j];
        spawns[j + 1] = thespawn;
    }

    first = [];
    second = [];
    third = [];
    outer = [];

    thirdSize = spawns.size / 3;
    for ( i = 0; i <= thirdSize; i++ )
        first[ first.size ] = spawns[i];
    for ( ; i < spawns.size; i++ )
    {
        outer[ outer.size ] = spawns[i];
        if ( i <= (thirdSize*2) )
            second[ second.size ] = spawns[i];
        else
            third[ third.size ] = spawns[i];
    }

    self.gameObject.nearSpawns = first;
    self.gameObject.midSpawns = second;
    self.gameObject.farSpawns = third;
    self.gameObject.outerSpawns = outer;
}

PickRadioToSpawn()
{
    avgpos["allies"] = (0,0,0);
    avgpos["axis"] = (0,0,0);
    num["allies"] = 0;
    num["axis"] = 0;

    for ( i = 0; i < level.players.size; i++ )
    {
        player = level.players[i];
        if ( isalive( player ) )
        {
            avgpos[ player.pers["team"] ] += player.origin;
            num[ player.pers["team"] ]++;
        }
    }

    if ( !num["allies"] || !num["axis"] )
    {
        radio = level.radios[ randomint( level.radios.size) ];
        while ( isDefined( level.prevradio ) && radio == level.prevradio )
            radio = level.radios[ randomint( level.radios.size) ];

        level.prevradio2 = level.prevradio;
        level.prevradio = radio;

        return radio;
    }

    avgpos["allies"] = avgpos["allies"] / num["allies"];
    avgpos["axis"] = avgpos["axis"] / num["axis"];

    bestradio = undefined;
    lowestcost = undefined;
    for ( i = 0; i < level.radios.size; i++ )
    {
        radio = level.radios[i];

        cost = abs( distance( radio.origin, avgpos["allies"] ) - distance( radio.origin, avgpos["axis"] ) );

        if ( isdefined( level.prevradio ) && radio == level.prevradio )
            continue;
        if ( isdefined( level.prevradio2 ) && radio == level.prevradio2 )
        {
            if ( level.radios.size > 2 )
                continue;
            else
                cost += 512;
        }

        if ( !isdefined( lowestcost ) || cost < lowestcost )
        {
            lowestcost = cost;
            bestradio = radio;
        }
    }

    level.prevradio2 = level.prevradio;
    level.prevradio = bestradio;

    return bestradio;
}

onPlayerKilled( eInflictor, attacker, iDamage, sMeansOfDeath, sWeapon, vDir, sHitLoc, psOffsetTime, deathAnimDuration )
{
    if ( !isPlayer( attacker ) || (!self.touchTriggers.size && !attacker.touchTriggers.size) || attacker.pers["team"] == self.pers["team"] )
        return;

    if ( self.touchTriggers.size )
    {
        triggerIds = getArrayKeys( self.touchTriggers );
        ownerTeam = self.touchTriggers[triggerIds[0]].useObj.ownerTeam;

        if ( ownerTeam != "neutral" )
        {
            team = self.pers["team"];
            if ( team == ownerTeam )
            {
                attacker thread [[level.onXPEvent]]( "assault" );
                maps\mp\gametypes\_globallogic::givePlayerScore( "assault", attacker );
            }
            else
            {
                attacker thread [[level.onXPEvent]]( "defend" );
                maps\mp\gametypes\_globallogic::givePlayerScore( "defend", attacker );
            }
        }
    }

    if ( attacker.touchTriggers.size )
    {
        triggerIds = getArrayKeys( attacker.touchTriggers );
        ownerTeam = attacker.touchTriggers[triggerIds[0]].useObj.ownerTeam;

        if ( ownerTeam != "neutral" )
        {
            team = attacker.pers["team"];
            if ( team == ownerTeam )
            {
                attacker thread [[level.onXPEvent]]( "defend" );
                maps\mp\gametypes\_globallogic::givePlayerScore( "defend", attacker );
            }
            else
            {
                attacker thread [[level.onXPEvent]]( "assault" );
                maps\mp\gametypes\_globallogic::givePlayerScore( "assault", attacker );
            }
        }
    }
}
